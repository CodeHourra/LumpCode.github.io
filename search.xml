<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次使用node.js的child_process模块来调用其他子进程学习]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8node-js%E7%9A%84child-process%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%90%AF%E5%8A%A8%E5%85%B6%E4%BB%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[背景 由于最近项目中遇到了一个问题,因公司项目是需要electron环境来运行,同时还依赖其他独立应用程序,所以出现了有一个场景: 就是在electron项目在被强制结束进程的情况下,独立程序并未被关闭,导致出现某些异常,所以现在需要在electron主进程重新启动时,关闭并重启依赖的其他独立应用程序(进程). 思路 首先会去寻找 electron 的官方文档,寻找是否本身就拥有调用和关闭其他进程的 API 来满足我们的需求.当然,经过一番寻找发现这条路是行不通的,官方并未提供这类 API. 我们接着可以发现官方文档有如下介绍: Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的.所以我们可以想到可以利用node.js相关能力来操作第三方程序来作为子进程. 实现 第一步,查看官方文档,如下: 123456789101112131415161718`child_process` 模块提供了衍生子进程的能力（以一种与 popen(3) 类似但不相同的方式）。 此功能主要由 `child_process.spawn()` 函数提供：const &#123; spawn &#125; = require('child_process');const ls = spawn('ls', ['-lh', '/usr']);ls.stdout.on('data', (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);ls.stderr.on('data', (data) =&gt; &#123; console.error(`stderr: $&#123;data&#125;`);&#125;);ls.on('close', (code) =&gt; &#123; console.log(`子进程退出，使用退出码 $&#123;code&#125;`);&#125;);默认情况下， stdin、 stdout 和 stderr 的管道会在父 Node.js 进程和衍生的子进程之间建立。 这些管道具有有限的（且平台特定的）容量。 如果子进程写入 stdout 时超出该限制且没有捕获输出，则子进程将会阻塞并等待管道缓冲区接受更多的数据。 这与 shell 中的管道的行为相同。 如果不消费输出，则使用 &#123; stdio: 'ignore' &#125; 选项。 看官方文档及实例可知,我们可以使用child_process模块的child_process.spawn()函数来调用指定的命令,并并捕获 stdout、 stderr、以及退出码. 无论在windows下还是在linux下,我们知道都可以通过执行相应的命令来启动其他应用程序,按照这个思路,我们可以利用child_process.spawn()函数来执行我们想要的命令,从而达到我们想要实现的效果.如果是想执行多条命令,例如首先查找该应用是否启动,若启动的话,先结束该进程,然后再启动它,我们可以编写一个批处理文件,同样可以使用child_process.spawn()函数来执行.官方对于使用.bat、.cad文件也给出了示例: 在 Windows 上衍生 .bat 和 .cmd 文件中英对照提交修改child_process.exec() 和 child_process.execFile() 之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，child_process.execFile() 可以更高效，因为默认情况下它不会衍生 shell。 但是在 Windows 上， .bat 和 .cmd 文件在没有终端的情况下不能自行执行，因此无法使用 child_process.execFile() 启动。 当在 Windows 上运行时，要调用 .bat 和 .cmd 文件，可以使用设置了 shell 选项的 child_process.spawn()、或 child_process.exec()、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 child_process.exec() 所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。 好的,到此我们就开始正式编码. child_process.exec() 和 child_process.execFile() 之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，child_process.execFile() 可以更高效，因为默认情况下它不会衍生 shell。 但是在 Windows 上， .bat 和 .cmd 文件在没有终端的情况下不能自行执行，因此无法使用 child_process.execFile() 启动。 当在 Windows 上运行时，要调用 .bat 和 .cmd 文件，可以使用设置了 shell 选项的 child_process.spawn()、或 child_process.exec()、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 child_process.exec() 所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。 因为child_process.exec()底层也使用了spawn()函数,所以我们直接选择使用child_process.spawn()来完成我们的需求 12345678910111213141516171819202122232425262728293031// 首先我们编写一个我们需要的.bat文件,代码如下,保存为startApp.batecho create softphone windows service@rem 进入当前文件夹cd /d %cd%# 以下命令可根据你想要启动的应用程序所在位置的不同而调整cd ../# 获取当前所在根目录的路径set rootPath=%cd%# 设置启动程序的路径set spPath=\xxxx\xxxx.exeset rdPath = \xxxx\xxxx.exe# 拼接完整路径地址set test1Path=%rootPath%%spPath%set test2Path=%rootPath%%rdPath%# 查找该进程是否启动,若启动则结束该进程tasklist | find /i "xxxx.exe" &amp;&amp; taskkill /F /im xxxx.exetasklist | find /i "test.exe" &amp;&amp; taskkill /F /im test.exe# 启动进程 '-a': 启动进程的参数start %test1Path% -astart %test2Path% -aecho start serviceexit 接下来使用child_process.spawn()函数来调用该批处理文件.首先展示一下目录结构. 123456|-src |-common |-startApp.bat |-test.js |- main.js该目录结构是在一个标准的 electron工程下的目录结构,调用.bat文件时要注意的一点就是文件与代码所处路径的问题. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 在common下新建一个test.js文件// 下面三个模块时为了在windows下一些输出错误信息中文字符会乱码的问题var iconv = require('iconv-lite');var encoding = 'cp936';var binaryEncoding = 'binary';function restartApp() &#123; // 引入spawn函数 const &#123; spawn &#125; = require('child_process'); const path=require('path'); // 使用cmd命令 `start restartApp`: 执行restartApp.bat const bat = spawn( ['/c', 'start restartApp'], &#123; cwd: path.join(__dirname,"../common"), //运行子进程的目录,此处千万要写对路径,否则会报'xxxx'不是不是内部或外部命令，也不是可运行的程序或批处理文件的提示 detached: true, //让父进程退出后，子进程能独立运行 shell: process.platform === 'win32', windowsHide: true &#125; ); bat.stdout.on('data', (data) =&gt; &#123; // 标准输出 console.log(data.toString()); &#125;); bat.stderr.on('data', (data) =&gt; &#123; // 输出错误信息 console.log('stderr: ' + iconv.decode(new Buffer(data, binaryEncoding), encoding), iconv.decode(new Buffer(data, binaryEncoding), encoding)); &#125;); bat.on('exit', (code) =&gt; &#123; console.log(`子进程退出，退出码 $&#123;code&#125;`); &#125;);&#125;closeService = () =&gt; &#123; const &#123; exec &#125; = require('child_process'); exec('tasklist | find /i "xxxx.exe" &amp;&amp; taskkill /F /im xxxx.exe', (error, stdout, stderr) =&gt; &#123; if(error !== null)&#123; console.info('stderr: ' + error); &#125; else console.info("成功") console.info('stdout: ' + stdout); console.info('stderr: ' + stderr); &#125;);&#125;;module.exports = &#123; restartApp, closeService&#125; 然后在electron项目里的main.js中调用 123456789101112131415161718...const &#123; app &#125; = require('electron');const &#123; restartApp &#125; = require('./test');...app.once('ready', () =&gt; &#123; ... // 调用刚刚的方法,在electron启动时,来重新启动其他进程 restartApp(); ...&#125;);app.on('window-all-closed', () =&gt; &#123; if (process.platform !== 'darwin') &#123; // electron关闭时,来关闭其他进程 closeService(); app.quit(); &#125;&#125;); 综上,就是一次使用在寻找如何在electron中创建其他子进程的全过程,在有一个需求之后我们首先应该去分析,为什么会产生这个需求,我们的目的是什么,有哪些熟知的手段去解决,然后可以去查看官方文档,一步一部的去尝试,就能解决问题.当然child_process模块中还有许多方法,可以实现类似的效果,还可以同步的创建子进程,监听相关事件然后响应,等待各位去探索.作者水平有限,文中有所不足之处还望大家不吝赐教. 参考资料Electron 文档 Node.js 中文网 v10.16.3]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+maven+mybatis整合时遇到一些需要注意的问题]]></title>
    <url>%2F2019%2F01%2F13%2Fspringboot-maven-mybatis%E6%95%B4%E5%90%88%E6%97%B6%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天在整合springboot+maven+mybatis遇到了一些问题，也花了一些时间去解决，其主要问题都是些配置的问题，由于版本的变动，相应的一些包的版本和配置文件的写法也会有些许不同，如果依旧按照之前的写法，可能编译通过，但是运行时就会报错，下面就简要记录一下遇到的一些坑。 mybatis-generator-core包无法下载 有的同学可能在此处会遇到该依赖无法下载下来，此时只需要将该依赖移到&lt;build&gt;&lt;/build&gt;标签外的&lt;dependencies&gt;&lt;/dependencies&gt;标签内就可以把jar包下载下来，再移回原处即可。只要有jar包就不会报错了，出现这个问题的原因尚不明确，笔者推测可能是maven的依赖传递存在的一些问题。 如图，找不到xml中的sql语句 该问题不影响springboot服务的正常启动，但是在访问该方法去执行mybatis生成的查询方法时则会出现，网上关于此类似的问题解决的方案主要分为三种： ​ 第一种：语法错误 Java DAO层接口 1public void delete(@Param(&quot;id&quot;)String id); Java 对应的mapper.xml文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;xxx.xxx.xxx.Mapper&quot;&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.String&quot;&gt; DELETE FROM xxx WHERE id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 检查：1. 接口中方法名（delete）与xml文件中 id=”delete”是否一致 2. xml文件中的 namespace=”xxx.xxx.xxx.Mapper” 中的路径是否与接口文件路径一致 3.parameterType类型 与 resultType类型是否准确；resultMap与resultType是不一样的。 ​ 第二种：编译错误 定位到项目路径下：target\classes\ 中报错路径下，寻找对应的xml文件是否存在。 （1）若不存在对应的xml文件，则需要在pom.xml中加入以下代码： 12345678910111213141516&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 删除classes文件夹中文件，重新编译，出现了对应的xml文件即可。 （2）若存在xml文件，则打开xml文件，检查其中报错部分是否与源文件一致，不一致，则 先清除classes文件夹中文件，执行命令：mvn clean 清理内容，重新编译后即可。 ​ 第三种：配置错误 在配置文件中指定扫描包时，配置路径有问题。例如：spring配置文件中”basePackage”属性包名的指定一定要具体到接口所在包，而不要写父级甚至更高级别的包 ，否则可能出现问题；cn.dao与cn.*也可能导致错误；注解扫描时，可能没有扫描到包等。 mysql版本及驱动包问题 我安装的MySQL版本为8.0.13，对应的mysql-connector-java包的版本应该为8.0.11,MySQL5.7之前的版本可以使用5.1.41，同时对应的MySQL8以上的数据库连接url及driver和之前的有所区别，当运行时出现有关数据连接方面的错误可以先检查一下数据库连接url，在MySQL8中url要指定ssl,编码格式，时区等。先将MySQL8的url及driver写法展示如下： application.yml中： 12345678910spring: datasource: data: miaosha url: jdbc:mysql://localhost:3306/miaosha?serverTimezone=UTC&amp;acharacterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT&amp;rewriteBatchedStatements=true username: root password: ****** #使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource # mysql8以上推荐的驱动包 driver-class-name: com.mysql.cj.jdbc.Driver mybatis-generator.xml中： 12345678&lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!--数据库连接地址账号密码--&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/miaosha?serverTimezone=UTC&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT&amp;amp;rewriteBatchedStatements=true" userId="root" password="******"&gt; &lt;/jdbcConnection&gt;&lt;/context&gt; 注：&amp;amp;为&amp;转义，在Idea中编写XML文件直接使用&amp;貌似会报错]]></content>
      <tags>
        <tag>Springboot</tag>
        <tag>Maven</tag>
        <tag>Mybatis</tag>
        <tag>MySQL</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker入门简易教程]]></title>
    <url>%2F2019%2F01%2F05%2Fdocker%E5%85%A5%E9%97%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 一. Docker简介关于Docker的介绍网上已经有了不少,简单来说,Docker是一种容器技术,但是是经过改进的容器技术,其改进的地方在于Docker容器引入了镜像,使的容器的创建和迁移变得方便快捷不少 Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 Docker明显的特点: 轻量,内存占用小,密度高 快速,启动时间为毫秒级 隔离,沙盒技术类似于虚拟机 Docker技术的基础： namespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid cgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory unionfs，典型：aufs/overlayfs，分层镜像实现的基础 Docker组件： docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作 docker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器 docker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的scm Docker的安装:安装在此处就不赘述, 因为其安装比较简单,且支持目前主流操作系统,相关Mac到Windows到Linux发行版的具体安装说明可以参考官方文档: docker安装 二.准备 Docker系统有两个程序: Docker服务端和Docker客户端.Docker服务端主要是作为管理所有容器的一个服务进程,管理着所有的容器.Docker客户端则相当于Docker服务端的远程控制器,可以用来控制Docker的服务端进程,Docker服务端和客户端通常情况下都运行在一台机器上。 本次的目标是安装Docker成功后检查Docker版本，以便确认Docker服务在运行并且可以通过客户端连接。 提示： 同其他Linux命令相似可以通过docker命令来查看所有的参数 通过docker version命令可以查看docker的版本 三.寻找可用的Docker镜像对于新手来讲，使用Docker最简单快捷的方式就是从现有容器镜像入手了，那么该如何去寻找现有的镜像呢，Docker官网专门有一个页面用来存储所有的可用镜像。（网址 ）。我们可以通过浏览这个网页来查找我们所需要的镜像或者是通过命令行工具来检索。 本节的目标是学会通过命令行工具来检索镜像。 命令行的用法为docker search 镜像名字 示例： 四.下载Docker镜像在第三小节中我们检索到了名为tutorial的镜像，我们可以使用如下命令来下载该镜像(docker命令和git命令有些类似的地方) 命令： docker pull learn/tutorial 当执行上述命令时可能会出现镜像已存在的情况，那么此时我们想删除之前的镜像该如何操作呢？如图所示： 总结： 当想删除镜像时，必须保证该镜像没有容器在使用，否则需要停止并删除该容器，才能进一步删除镜像。 停止所有的container，这样才能够删除其中的images：docker stop $(docker ps -a -q) 如果想要删除所有container的话再加一个指令：docker rm $(docker ps -a -q) 查看当前有些什么images: docker images 删除images，通过image的id来指定删除谁:docker rmi &lt;image id&gt; 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用 docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;) 要删除全部image的话docker rmi $(docker images -q) 五. 在Docker容器中运行“hello docker”通过docker run命令可以启动某一个镜像并运行一个命令 在此之前我们可能会问，什么是docker容器呢，和docker又有什么区别呢？ docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行的所有的必须的资源包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 而docker则是一种容器技术· 现在我们想在刚刚下载的镜像中输出”hello docker”。为了达到这个目的，我们需要在这个容器中运行”echo”命令，输出”hello docker”。 六. 如何在容器中安装新程序下一步我们要做的事情是在容器里面安装一个简单的程序(ping)。你可以使用apt-get命令来安装ping程序： apt-get install -y ping。 备注：apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。 现在我们想在learn/tutorial镜像里面安装ping程序。 在执行apt-get命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。 七. 保存对容器的修改当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。docker中保存状态的过程称之为committing，它保存的新旧状态之间的区别，从而产生一个新的版本。 首先使用docker ps -l命令获得安装完ping命令之后容器的id。然后把这个镜像保存为learn/ping。 运行docker commit，可以查看该命令的参数列表。 你需要指定要提交保存容器的ID。(译者按：通过docker ps -l 命令获得) 无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分。（备注：非常类似git里面的版本号) 八. 运行新的镜像ok，到现在为止，你已经建立了一个完整的、自成体系的docker环境，并且安装了ping命令在里面。它可以在任何支持docker环境的系统中运行啦！下面就让我们来体验一下吧！ 在新的镜像中运行ping www.baidu.com（当然也可以www.google.com， but……）命令。 一定要使用新的镜像名learn/ping来运行ping命令。(注：最开始下载的learn/tutorial镜像中是没有ping命令的) 九. 检查运行中的镜像现在你已经运行了一个docker容器，让我们来看下正在运行的容器。 使用docker ps命令可以查看所有正在运行中的容器列表，使用docker inspect命令我们可以查看更详细的关于某一个容器的信息。 查找某一个运行中容器的id，然后使用docker inspect命令查看容器的信息。 可以使用镜像id的前面部分，不需要完整的id。 十. 发布自己的docker镜像现在我们已经验证了新镜像可以正常工作，我们可以选择将其发布到官方的索引网站。还记得我们最开始下载的learn/tutorial镜像吧，我们也可以把我们自己编译的镜像发布到索引页面，一方面可以自己重用，另一方面也可以分享给其他人使用。 docker push命令可以将某一个镜像发布到官方网站。 注：push之前需要我们登陆docker repository的账号，这里就不再赘述了。 参考资料docker中文网 一小时Docker教程]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关Hexo博客图片插件使用报错问题]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%9C%89%E5%85%B3Hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在我们搭建好Hexo博客平台后,我们通常都会尝试写一篇博客去测试是否搭建成功,但是在博客里通常带有一些图片,在没有经过配置的情况下,图片是不会被正常显示的,下面就来简单介绍一下如何来配置让图片能够正常显示. hexo默认无法自动处理文章插入本地图片，需要通过扩展插件支持。 首先找到配置_config.yml文件中的post_asset_folder:false这个选项设置为true,启动 Asset 文件夹.当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间,安装插件） 完成安装后,运行hexo n &quot;xxxx&quot;来生成md博文时会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── test1.jpg├── test2.jpg└── test3.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用标准的md语法来引入![logo](本地图片测试/test1.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── test1.jpg├── index.html├── test2.jpg└── test3.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/test1.jpg&quot; alt=&quot;test1&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/test1.jpg&quot; alt=&quot;test1&quot;&gt; Issue: 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。 在代码中加入： 123456789var version = String(hexo.version).split('.');修改date.permalink处理：var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1;else var beginPos = getPosition(link, '/', 3) + 1;重新生成静态文件即可正确显示。 可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save 参考链接：https://www.jianshu.com/p/3db6a61d3782]]></content>
      <tags>
        <tag>小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular与其他前端框架的对比]]></title>
    <url>%2F2018%2F10%2F04%2FAngular%E4%B8%8E%E5%85%B6%E4%BB%96%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[与React对比 速度:react会先更新虚拟dom,再和实际dom进行对比 angular与之不相上下 FLUX架构:组件化 数据单向更新 服务器端渲染 预渲染 seo优化 与vue对比 个人主导(angular为google开发,号召力资金充足,vue相对来说有些不足) 只关注web(angular还可以开发客户端应用) 服务器端渲染(vue通过第三方库,angular有官方库) angular程序架构 组件:是Angular应用的基本构建块,你可以把一个组件理解为一段带有业务逻辑和数据的html 服务:用来封装可重用的业务逻辑 指令:允许你向html中添加自定义行为 模块:用来将应用中不同的部分组织成一个Angular框架可以理解的单元 组件、服务、模块是为了完成某些功能的,模块是为了打包、分发这些功能的. 组件组件(Component)必备三要素: 装饰器( @Component() ): 模版(Template) 控制器(Controller) 控制器←→控制器进行数据绑定 :插值表达式 启动angular应用 启动时加载了哪个页面?angular.json中有一项index属性，该属性对应的src目录下的indexhtml指向的是root src目录下的index.html,main属性则指向src下的main.ts文件 启动时加载了哪些脚本?main.ts 这些脚本做了什么事?负责引导angular应用的启动,引入相关的库及文件,来帮助angular应用程序启动 如何引用第三方类库(2-5)开发准备 npm install 安装到本地库 package.json -&gt; dependencies 引入到项目中 angular6 后在angular.json中在styles/script中分别引入,之前的版本在angular-cli.json中 npm install @types/jquery -D 安装jquery的ts类型描述文件,npm i @types/bootstrap -D安装bootstrap的ts类型描述文件 组件开发 App组件 导航栏组件 页脚组件 搜索表单组件 轮播图组件 商品展示组件 星级评价组件 *ngFor:指令 命令自动生成组件 ng g component xxx 在当前项目下生成组件 商品展示组件重点:angular始终是根据后台数据的变化来生成页面的,而不是去操纵dom元素 bootstrap元素居中:在bootstrap中实现元素居中的方法主要有这几种： 加类.text-center（子元素居中） 加类.center-block（自身居中） 利用bootstrap中列偏移的概念。例如：col-md-offset-2(外边距向右偏移两列) 数据绑定 通过插值表达式 直接将对象的属性展示出来 属性绑定:&lt;img [src]=&quot;imgUrl&quot; alt=&quot;商品图片&quot;&gt; 通过[]将标签属性绑定控制器的属性 样式绑定: [class.glyphicon-star-empty]=&quot;star&quot; 前面的class表示的是我后面要绑定的是一个class样式这个样式是由star的值决定的,star为true时会多出这么个样式,反之则不会 属性传递:]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由中传递参数]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%B7%AF%E7%94%B1%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[修改路由配置中的path属性,使其可以携带参数 path: &#39;product/:id&#39; path的参数后加上 /:id 名为id变量 12345678910111213141516const routes: Routes = [ &#123;path: '', redirectTo: '/home', pathMatch: 'full'&#125;, &#123;path: 'chat', component: ChatComponent, outlet: 'aux'&#125;, &#123;path: 'home', component: HomeComponent&#125;, &#123;path: 'product/:id', component: ProductComponent, children: [ &#123;path: '', component: ProductDescComponent&#125;, &#123;path: 'seller/:id', component: SellerINfoComponent&#125; ],canActivate: [LoginGuard],canDeactivate: [UnsavedGuard], resolve: &#123; product: ProductResolve &#125;&#125;, &#123;path: '**', component: Code404Component&#125;]; 修改路由链接的参数来传递参数 &lt;a [routerLink]=&quot;[&#39;/product&#39;, 2]&quot; &gt;商品详情页&lt;/a&gt; 在控制器中修改代码 1234ngOnInit() &#123; // 参数订阅 订阅后声明一个匿名函数传进来之后从参数中取出ID赋值给本地的product // subscribe rxjs的语法 this.routeInfo.params.subscribe((params: Params) =&gt; this.productId = params['id']);]]></content>
      <tags>
        <tag>Angular6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 在layout 为 draft 的情况使用记录]]></title>
    <url>%2F2018%2F10%2F04%2FHexo%20%E5%9C%A8layout%20%E4%B8%BA%20draft%20%E7%9A%84%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[layout 为 draft 的情况通过以上的学习，我们大概了解了一般情况下生成一篇博客的流程以及各个内容设置对页面效果的影响。那么我们现在学习一下 hexo new draft myDraftBlog 的情况。在没有执行这个命令之前，你可以去看下你的source文件夹，如果你是按照我之前的文章一步步进行的话，你会发现其中只有_post一个文件夹。 当我们执行上面的命令之后，类似post一样，我们同样会发现在根目录下source/_drafts文件夹中会出现一个myDraftBlog.md的文件。也就是说，_draft文件夹和里面的内容是你执行上述命令之后生成的。同样的，你开始编辑myDraftBlog.md文件，然后保存。 以此执行hexo g 和 hexo s 命令，打开4000端口之后你会发现，你完全看不到你刚才编辑的myDraftBlog这篇博客。这是为什么呢？因为layout 为 draft的时候，其实这个md文件是草稿状态，也就是说，这篇文章仅仅是作为你的草稿而不是正式稿，所以不会发表在博客主页上。草稿就是需要你不断完善的文章，知道有一天你觉得这篇文章可以正式发表了，那么如何才能将草稿发表成为正式稿件呢？官方文档其实有非常详细的说明：上面的官方文档会告诉你，通过publish命令可以将draft移动到_post文件夹下，形成正式的博客。也就是说，当你认为你的草稿已经完善到可以发表的状态时，执行hexo publish draft myDraftBlog.md，你就会发现，source/_draft文件夹下的myDraftBlog.md文件消失了，而在_post文件夹下你会找到myDraftBlog.md文件。这个时候再按照生成post文件的方式，依次执行hexo g hexo d 就可以将这篇草稿正式转为发表在网上的博客了。 因此，draft都是草稿，需要和publish命令配合使用。 当然，根据上面的官网说明，如果我们一定要查看我们的草稿，我们可以使用hexo g --draft， hexo s --draft命令来在本地预览我们的草稿效果。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
